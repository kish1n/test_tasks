# Longest UTXO Chain Finder

## Опис
Це застосування аналізує блокчейн транзакції та знаходить найдовший ланцюг UTXO (Unspent Transaction Outputs). Програма зчитує транзакції з файлу, фільтрує їх відповідно до правил (один вхід, два виходи), будує граф залежностей транзакцій та знаходить найдовший ланцюг.

## Як запустити
1. Встановіть Python 3.6 або вище.
2. Збережіть код у файл `utxo_chain_finder.py`.
3. Підготуйте текстовий файл з даними про транзакції. Формат файлу: `tx1: input_tx1, 0 -> address1, 0.5; address2, 0.5
tx2: tx1, 0 -> address3, 0.25; address4, 0.25`
4. Запустіть програму, передавши шлях до файлу з транзакціями:
```bash
python utxo_chain_finder.py <path_to_transaction_file>
```
Приклад коду python utxo_chain_finder.py transactions.txt

##Формат файлу транзакцій
1. `txid`: Ідентифікатор транзакції.
2. `inputs`: Вхідні транзакції у форматі txid, index.
3. `outputs`: Вихідні адреси та суми у форматі address, amount.

## Пояснення коду
#### Основні функції
###### `build_graph`
Функція `build_graph` будує граф залежностей транзакцій, де вузли - це транзакції, а ребра - це залежності між ними (вихід однієї транзакції є входом для іншої).
```python
def build_graph(self, filtered_txs):
    graph = {}

    for tx in filtered_txs:
        tx_outputs = [(tx.txid, i) for i in range(len(tx.outputs))]
        for tx_out in tx_outputs:
            for next_tx in filtered_txs:
                if tx_out in next_tx.inputs:
                    if tx.txid not in graph:
                        graph[tx.txid] = []
                    graph[tx.txid].append(next_tx.txid)
    return graph
```

## Алгоритм роботи:

1. Ініціалізує порожній граф (словник).
2. Для кожної транзакції з фільтрованого списку отримує всі виходи.
3. Перевіряє, чи використовуються ці виходи як вхід для інших транзакцій.
4. Якщо так, додає залежність у граф.

#### `find_longest_chain`
Функція `find_longest_chain` знаходить найдовший ланцюг транзакцій у графі залежностей за допомогою глибокого пошуку (DFS).

```python
def find_longest_chain(self, graph):
    visited = set()
    longest_chains = []
    longest_length = 0

    def dfs(txid, path):
        nonlocal longest_chains
        nonlocal longest_length
        path.append(txid)
        visited.add(txid)

        if len(path) > longest_length:
            longest_length = len(path)
            longest_chains = [path[:]]  # Скинути список, якщо знайдено довший ланцюг
        elif len(path) == longest_length:
            longest_chains.append(path[:])  # Додати ланцюг, якщо він такої ж довжини

        for neighbor in graph.get(txid, []):
            if neighbor not in visited:
                dfs(neighbor, path)

        path.pop()
        visited.remove(txid)

    for txid in graph:
        dfs(txid, [])

    return longest_chains
```

#### Алгоритм роботи:

1. Ініціалізує множину відвіданих вузлів, список найдовших ланцюгів та змінну для зберігання довжини найдовшого ланцюга.
2. Визначає функцію dfs для глибокого пошуку в графі:
3. Додає поточний вузол до шляху та множини відвіданих.
4. Оновлює найдовший ланцюг, якщо знайдено новий найдовший або ланцюг такої ж довжини.
5. Рекурсивно викликає dfs для сусідніх вузлів, якщо вони ще не були відвідані.
6. Видаляє поточний вузол зі шляху та множини відвіданих після завершення обробки.
7. Запускає dfs для кожного вузла в графі.
8. овертає список найдовших ланцюгів.

#### Деталі про графи
Графи використовуються для моделювання залежностей між транзакціями в блокчейні. У цьому випадку:

1. Вузли (Nodes): Транзакції.
2. Ребра (Edges): Залежності між транзакціями, де вихід однієї транзакції є входом для іншої.
3. Граф дозволяє ефективно представляти та аналізувати зв'язки між транзакціями, що робить можливим знаходження найдовшого ланцюга UTXO за допомогою алгоритмів обходу графа, таких як глибокий пошук (DFS).

## Чому моє рішення ефективне
Моє рішення є ефективним завдяки використанню графів для моделювання залежностей транзакцій та алгоритмів обходу графа для знаходження найдовших ланцюгів:

1. Графова структура: Дозволяє ефективно представляти та аналізувати залежності між транзакціями.
2. DFS для знаходження найдовшого ланцюга: Глибокий пошук дозволяє знайти найдовші шляхи у графі, що відповідає нашим вимогам щодо аналізу UTXO.
## Класифікація у Big O нотації
1. Зчитування та створення об'єктів Transaction: O(N), де N - кількість транзакцій.
2. Побудова графа залежностей: O(N^2), у найгіршому випадку, коли кожна транзакція може бути пов'язана з кожною іншою.
3. Знаходження найдовшого ланцюга за допомогою DFS: O(N + E), де N - кількість вузлів, а E - кількість ребер у графі.