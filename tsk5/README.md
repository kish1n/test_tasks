# Bitcoin Miner

## Опис
Це застосування аналізує транзакції Bitcoin і конструює блок, який максимізує прибуток від комісій. Програма отримує на вхід CSV файл з інформацією про транзакції і обирає оптимальний набір транзакцій для включення в блок з обмеженням по розміру блоку в 1MB.

## Як запустити
1. Встановіть Python 3.6 або вище.
2. Встановіть необхідні бібліотеки:
   ```bash
   pip install psutil
    ```
   
3. Запустіть програму:
4. Підготуйте CSV файл з даними про транзакції. Формат файлу: 
`tx_id,size,fee
tx1,500,2000
tx2,300,1500`
5. python bitcoin_miner.py <path_to_csv>

## Формат CSV файлу
1. `tx_id`: Ідентифікатор транзакції.
2. `size`: Розмір транзакції у байтах.
3. `fee`: Комісія транзакції в сатоші.

## Пояснення коду
#### Основні функції:
Функція `load_transactions` зчитує дані з CSV файлу та створює список об'єктів `Transaction`.

```python
def load_transactions(file_path):
    transactions = []
    try:
        with open(file_path, 'r') as file:
            reader = csv.reader(file)
            next(reader)
            for row in reader:
                tx_id, size, fee = row
                transactions.append(Transaction(tx_id, size, fee))
    except FileNotFoundError:
        print(f"Error: The file {file_path} does not exist.")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
    return transactions
```

1. Відкриває CSV файл для читання.
2. Зчитує дані построчно, пропускаючи заголовок.
3. Створює об'єкти Transaction для кожного рядка і додає їх до списку transactions.
4. Обробляє можливі помилки, такі як відсутність файлу або інші виключення.
5. Повертає список транзакцій.

`construct_block`

Функція `construct_block` вибирає оптимальний набір транзакцій для включення в блок, максимізуючи загальну комісію і при цьому не перевищуючи обмеження за розміром блоку в 1MB.

```python
def construct_block(transactions, max_block_size=1000000):
    transactions.sort(key=lambda x: x.fpb, reverse=True)

    total_size = 0
    total_fee = 0
    block_transactions = []

    for tx in transactions:
        if total_size + tx.size <= max_block_size:
            block_transactions.append(tx)
            total_size += tx.size
            total_fee += tx.fee
        if total_size >= max_block_size:
            break

    return block_transactions, total_size, total_fee
```

#### Алгоритм:
1. Сортує список транзакцій за співвідношенням комісія/розмір (fee per byte), у порядку спадання.
2. Ініціалізує змінні для відстеження загального розміру блоку (total_size), загальної комісії (total_fee) і списку транзакцій у блоці (block_transactions).
3. Перебирає відсортовані транзакції і додає їх до блоку, доки загальний розмір блоку не перевищить максимальний допустимий розмір.
4. Повертає список транзакцій, що увійшли до блоку, їх загальний розмір і загальну комісію.

## Детальне пояснення алгоритму

`load_transactions`
Функція load_transactions має ключову роль в підготовці даних для подальшої обробки. Вона зчитує транзакції з файлу і створює об'єкти Transaction, що включають ідентифікатор транзакції, розмір та комісію. Обробка виключень дозволяє зупинити виконання програми з відповідним повідомленням, якщо виникають помилки при зчитуванні файлу.

`construct_block`
Ця функція є основною для конструювання блоку транзакцій. Алгоритм починається з сортування транзакцій за співвідношенням комісія/розмір (fee per byte), що дозволяє спочатку вибирати найвигідніші транзакції з точки зору комісії. Потім, перебираючи відсортовані транзакції, функція додає їх до блоку до тих пір, поки загальний розмір блоку не досягне максимального значення. Це забезпечує максимізацію загальної комісії блоку при дотриманні обмеження за розміром.

## Чому рішення ефективне
Моє рішення є ефективним завдяки використанню сортування та жадібного алгоритму для вибору транзакцій:

1. Сортування за співвідношенням комісія/розмір: Це дозволяє спочатку вибирати найбільш вигідні транзакції.
2. Жадібний алгоритм: Додає транзакції до блоку доти, поки це можливо за розміром, що забезпечує максимізацію загальної комісії.

## Класифікація у Big O нотації
1. Читання CSV файлу та створення об'єктів Transaction: O(N), де N - кількість транзакцій у файлі.
2. Сортування транзакцій: O(N log N), де N - кількість транзакцій.
3. Конструювання блоку: O(N), де N - кількість транзакцій, оскільки кожна транзакція перевіряється лише один раз.

Загальна складність алгоритму: O(N log N), що є ефективним для обробки великої кількості транзакцій.

